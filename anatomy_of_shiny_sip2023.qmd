---
title: "Anatomy of a Shiny app"
subtitle: "Shiny in Production 2023"
institute: "Barnett Waddingham"
author: "Chris Brownlie"
date: "2023-10-13"
date-format: "Do MMM YYYY"
format:
  revealjs: 
    theme: [dark, custom.scss]
    footer: "Shiny in Production 2023"
    embed-resources: true
    output-file: index.html
    slide-number: true
---

## About me

- Chris Brownlie
- Analytics consultant @ Barnett Waddingham
- 5 years with R & shiny
- Expertise on {shiny} and processes

## It is a weird title

- Anatomy of a shiny app AKA a high level look at the {shiny} source code
- This will be theoretical, but bear with me - it will be worth it!
- What I won't be talking about:
  - javascript & websockets
  - UI design
  - deployment/infrastructure
  
:::{.notes}
- Title is anatomy...
- What does that mean? Could also be called
- Will be theoretical, in the middle. Reasoning will make more sense at end
- Won't be talking about these points, although they are important
:::
  
## What do you mean 'anatomy'?

- Visible = UI
- Brain = Server
- *Organs = {shiny} and friends*
 
:::{.notes}
- Analogy that helps, think of an app as a person
- What we can see like the body shape, size etc. is the UI
- Brain is like the server, which takes in information from the user and performs some task in response
- The shiny package (and other packages) provide the 'organs' in this analogy
- They are mostly hidden, aren't visibly responsible for anything that happens but the app wouldn't function without them
- Using this analogy, developing an app is like designing a video game character
- You can choose how they look and what their personality is, but you don't have to worry about designing their organs as its taken care of
- Can indirectly interact with organs i.e. increase stamina -> bigger lungs, but you don't have to worry about how the lungs operate
- Bonus: websockets are the nervous system (communication between server and UI)
:::
  
## My hopes and dreams (for this talk)

- Better mental model
- De-magic-ify
- Improve app design

:::{.notes}
- The key reason I decided to do this talk is I think people struggle with mental models of shiny
- Reason being it is very easy to build complex apps without ever thinking about how or why it works
- {shiny} purposely abstracts away the complexity
- But I think having a good mental model for how it 'actually works' can only be a good thing
- Lots of people, especially those new to R and/or shiny will view it as magic, can be intimidating
- It is just clever coding and good design, with a lot of moving parts
- Hopefully the two points above will result in being able to build better apps, avoid common mistakes and design apps in a way more consistent with the {shiny} philosophy
:::

## Pre-requisite: R6

- {R6} provides a method of OOP
- Important for {shiny}
- Reference semantics
  
:::{.notes}
- Main thing I'll be talking about today is R6 classes
- Alternative to S3 in that they both provide OOP frameworks, but do it very differently
- If you've used python, R6 is much closer to a Python object than to S3 or 4
- {shiny} uses these extensively to manage the complex behaviour and possibilities of an app
- One key characteristic of R6 is reference semantics, I won't go into detail here
- Makes it easy to maintain state across multiple function calls
- Why it is used extensively in shiny
:::

## [A subjective classification]{.smaller}

![Shiny R6 classes](img/shiny_r6_classes6.png)

## When are they created

- **On load**: RLog, TimerCallbacks, HandlerManager
- **In `runApp()`**: [ShinySession]{.col-cyan}, Bookmarking classes
- **In the app event loop**: [ReactiveEnvironment]{.col-cyan}, Core Helpers
- **User-dependent** (mostly):
  - [ReactiveVal]{.col-cyan} (`reactiveVal()`)
  - [ReactiveValues]{.col-cyan} (`reactiveValues()`)
  - [Observers]{.col-cyan} (`observe()`, `observeEvent()`, `render_X()`)
  - [Observable]{.col-cyan} (`reactive()`)
  
:::{.notes}
- The objects are created and used at different times throughout the lifecycle of a shiny app
- Some are created when the package is loaded, these are stored in the hidden global environment that shiny uses
- Others are only created once the app starts running, either on startup of the app or during the running of app itself
- The event loop is where most of the actual 'reactivity' takes place
- The classes with user-facing wrappers are mostly used by developers, although there are some places within the code
where they are used implicitly or as defaults
:::

## [ShinySession]{.col-cyan}

- You might recognise: `session`
- Contains instances of most helper/core helper classes
- Important tasks
  - Communicates with browser via websockets
  - Handles outputs in the server
  - Initiates and manages 'cycles'
  
:::{.notes}
- For most shiny apps, the server is initiated with three arguments (input, output and session)
- The session is an instance of ShinySession and when you interact with it via session$, you're calling a method of the ShinySession class
- ShinySession is in some ways the overarching class, an instance can be thought of as the home/top level of the app
- It stores a lot of different objects, using the helper classes and acting as a way to access those objects
- Arguably the most important job it does for the use is manage websocket communications
- Without the websocket communications, there would be no reactivity
- Another important job is handling outputs
- This involves converting what is provided via render functions into an observer that executes when its inputs
are invalidated
- This includes communicating with the browser that an output is recalculating and other stuff like making sure 
it is named appropriately and easy to debug
- It manages app (flush) cycles, which means the process of executing all necessary code e.g. after an input has changed
- It keeps track of 'things that need to be done' and 'keep doing them until there isn't any more things to be done'
- Also the 'gateway' to things like bookmarking, modules, file uploads etc.

Qs?
- What are input/output? input is an instance of ReactiveValues, output is a list of Observers
:::

<!-- ## Stars of the show - [RLog]{.col-cyan} -->

<!-- - Logs actions on the reactive graph -->
<!-- - When things get invalidated etc. -->
<!-- - An instance of this is initiated (rLog) when the package is loaded -->

<!-- :::{.notes} -->
<!-- - It keeps a record of all reactive tasks that occur from when the shiny package is loaded -->
<!-- - This includes creating -->
<!-- ::: -->

## [ReactiveEnvironment]{.col-cyan} & [Context]{.col-cyan}

- ReactiveEnvironment keeps track of Contexts
- Contexts can be **invalidated** (notify the ReactiveEnvironment they need to be 'flushed')
- Contexts can be **flushed** (the function is run)

:::{.notes}
- Two of the most important objects that don't have a visible wrapper
- Handles much of the 'construction of the reactive graph'
- Contexts are used to keep track of reactive objects, when they need to be recalculated and what else depends on them
- A change in the client is received as a callback by ShinySession via websocket
- This updates any inputs, which invalidates any dependents
- The dependents are then recalculated (flushed) via the app event loop
:::

## [ReactiveVal]{.col-cyan} & [ReactiveValues]{.col-cyan}

- You might recognise: `reactiveVal()` and `reactiveValues()`
- Distinct but similiar
- Keep track of value, label and dependents

:::{.notes}
- ReactiveVal of the simplest types of reactive object/'reactive producer' within an app
- Has methods for getting and setting the value
- Setting the value invalidates any dependents
- ReactiveValues works in a similiar way but isn't just a list of ReactiveVals
- Has to also keep track of names and keys etc. which makes it more complicated
- Still boils down to the same thing, a value which has dependents, which should
be invalidated if the value ever changes
:::

## [Observer]{.col-cyan}

- You might recognise: `observe()`/`observeEvent()`
- Handling for invalidation (a non-isolated reactive value changes)
- Handling for flushes (app cycle, values have been recalculated)

:::{.notes}
- This is essentially a function that is run whenever it is 'invalidated'
- Technically it creates a Context that adds pending flush when invalidated
- And runs the function itself when flushed
- Other things invalidate it (ReactiveVals and reactives() etc.) via their Dependents
- Watches for things to change and then performs an action in response
:::

## [Observable]{.col-cyan}

- You might recognise: `reactive()`
- Turns an expression into a function
- Notifies dependents

:::{.notes}
- Observable objects are created with the reactive function
- They convert their expression to a function in the same way an Observer does
- It can both take in reactive objects and be used in other reactive expressions or consumers
- In a way it combines ReactiveVals and Observers, because it notifies dependents when it changes
- But it also watches for invalidation and reruns when invalidated
:::

## What is the point of all this?

- Some common design mistakes
- reactive vs observe
  - i.e. ReactiveVal/ues vs Observable vs Observer
- Overly reactive expressions
  - Understanding the reactive graph
- Misunderstanding modules
  - ShinySession, namespaces and input-output interactions
  
:::{.notes}
- Understanding the difference between the three types of object (called reactive producers, consumers and expressions (or both) in some shiny documentation)
- Can help to reduce incorrect usage, which is a common mistake for newer shiny developers
- In particular, do other things need to know if this value changes?
- Observer runs a function when invalidated, reactive recalculates and notifies dependents of a new value

- Overly reactive expressions - note that Observers are invalidated every time something they depend on is invalidated
- Can use things like `isolate` to remove the dependency on another object and avoid unnecessary invalidation
- The event loop has to flush everything thats invalidated before normal use of the app can continue
- So reducing the number of times shiny 'does something' can only be a good thing

- Calling a module just creates a new child domain from the original session
- Understand that it is a relatively simple hierarchy from the original ShinySession object
:::

## To conclude

- Might seem unimportant, hidden for a reason
- Mental models are hard
- Understanding the tools we use is good

:::{.notes}
- 99% of us will never need to know about these objects, shiny has been designed that way to abstract away the complexity and make our lives easier as developers
- But having a better mental model of what is going when you’re building an app can help you to make more thoughtful, conscious design choices and help you use shiny the way it was intended to be used
- I believe this can help reduce the chances of bugs and lead to better production shiny apps
:::

## Just for fun {.column-screen .smaller}

My favourite comments from the {shiny} source code

*(AKA shiny devs are like you and me, just better)*


![](img/funny_comments/abusing_downloads.PNG)
![](img/funny_comments/bunch_of_ugliness.PNG)
![](img/funny_comments/horribly_inefficient.PNG)
![](img/funny_comments/not_sure_why.PNG)
![](img/funny_comments/pity_about_copy_paste.PNG)
![](img/funny_comments/sob.PNG)
![](img/funny_comments/super_paranoid.PNG)
![](img/funny_comments/throw_yes_throw.PNG)
